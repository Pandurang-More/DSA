/****************************************************************************************
CYCLE DETECTION IN UNDIRECTED GRAPH (DFS)
****************************************************************************************

Given:
- V → Number of vertices
- edges → List of undirected edges

Return:
- true  → If cycle exists
- false → If no cycle exists

----------------------------------------------------------------------------------------
APPROACH:
1. Convert edge list to adjacency list.
2. Use DFS traversal.
3. Track parent node to avoid false cycle detection.
4. If a visited node is found that is NOT parent → cycle exists.

Time Complexity  : O(V + E)
Space Complexity : O(V)
****************************************************************************************/

class Solution {
public:

    bool isCycleDfs(vector<vector<int>>& adj, int u,
                    vector<bool>& visited, int parent)
    {
        visited[u] = true;

        for (int &v : adj[u])
        {
            if (v == parent) 
                continue;

            if (visited[v]) 
                return true;

            if (!visited[v] && isCycleDfs(adj, v, visited, u))
                return true;
        }

        return false;
    }

    bool isCycle(int V, vector<vector<int>>& edges) 
    {
        vector<vector<int>> adj(V);

        // Build adjacency list
        for (auto &e : edges)
        {
            int u = e[0];
            int v = e[1];

            adj[u].push_back(v);
            adj[v].push_back(u);
        }

        vector<bool> visited(V, false);

        // Check cycle in every component
        for (int i = 0; i < V; i++)
        {
            if (!visited[i] && isCycleDfs(adj, i, visited, -1))
                return true;
        }

        return false;
    }
};
