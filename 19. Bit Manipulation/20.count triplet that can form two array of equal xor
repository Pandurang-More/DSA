Given an array of integers arr.

We want to select three indices i, j and k where
(0 <= i < j <= k < arr.length).

Let's define a and b as follows:

a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]

Note that ^ denotes the bitwise-xor operation.

Return the number of triplets (i, j and k) where a == b.


Example 1:

Input:  arr = [2, 3, 1, 6, 7]
Output: 4

Explanation:
The triplets are
(0, 1, 2),
(0, 2, 2),
(2, 3, 4),
(2, 4, 4)


Example 2:

Input:  arr = [1, 1, 1, 1, 1]
Output: 10


Constraints:

1 <= arr.length <= 300
1 <= arr[i] <= 10^8



class Solution {
public:
    int countTriplets(vector<int>& arr) 
    {  
        int n = arr.size();
        int count = 0;

        vector<int> prefix(n + 1);

        for (int i = 0; i < n; i++)
            prefix[i + 1] = prefix[i] ^ arr[i];               // store the prefix value at each index

        prefix[0] = 0;

        for (int i = 0; i < prefix.size(); i++)
        {
            for (int j = i + 1; j < prefix.size(); j++)
            {
                if (prefix[i] == prefix[j])                // if both index prefix match means at between the index they have samw xor
                    count += j - i - 1;
            }
        }

        return count;
    }
};
