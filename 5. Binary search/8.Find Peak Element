
A peak element is an element that is strictly greater than its neighbors.

Given a 0-indexed integer array nums, find a peak element, and return its index.  
If the array contains multiple peaks, return the index to any of the peaks.

You may imagine that nums[-1] = nums[n] = -âˆž.  
In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

You must write an algorithm that runs in O(log n) time.


Example 1:

Input: nums = [1,2,3,1]  
Output: 2  

Explanation:  
3 is a peak element and your function should return the index number 2.


Example 2:

Input: nums = [1,2,1,3,5,6,4]  
Output: 5  

Explanation:  
Your function can return either index number 1 where the peak element is 2,  
or index number 5 where the peak element is 6.


Constraints:

1 <= nums.length <= 1000  
-231 <= nums[i] <= 231 - 1  
nums[i] != nums[i + 1] for all valid i.


Approach 1:

class Solution {
public:
    int findPeakElement(vector<int>& nums) 
    {    
        int n = nums.size();
        if(n == 1)
            return 0;

        int i = 0;
        if(n == 2)
        {
            if(nums[i] < nums[i+1])
                return i+1;
            else
                return i;
        }

        for(int i = 1; i < nums.size() - 1; i++)
        {
            if(nums[i-1] < nums[i] && nums[i] > nums[i+1])
                return i;
        }

        // Check last element
        if(nums[n - 1] > nums[n - 2])
            return n - 1;

        return 0;
    }
};


Approach 2:

given that it is a mountain array. so we have to encounter a point at which peak appear  
i.e. < , > sign apperar consecutive.

moountain index:  
arr[i-1] < arr[i] > arr[i+1]

class Solution
{
public:
    int findPeakElement(vector<int>& nums) 
    {    
        int n = nums.size();
        int i = 0;

        while(i < nums.size() - 1 && nums[i] < nums[i+1])    
        // this loop when the grater sign enounter means, peak element.
        {
            i++;
        }

        return i;
    }
};


Approach 3:

Binary Search;

class Solution
{
public:
    int findPeakElement(vector<int>& nums) 
    {    
        int n = nums.size();
        int start = 0;
        int end = n - 1;

        while(start < end)
        {
            int mid = start + (end - start) / 2;

            if(nums[mid] < nums[mid + 1])
            {
                start = mid + 1;                // mountain index will lied in right side.
            }
            else if(nums[mid] > nums[mid + 1])
            { 
                end = mid;                        // mountain inde will lied in mid or less than it
            }
        }

        return start;                         // at last only one element left pointing to peak element.
    }
};
