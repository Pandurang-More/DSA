Given an integer array nums where every element appears three times
except for one, which appears exactly once.
Find the single element and return it.

You must implement a solution with a linear runtime complexity
and use only constant extra space.


Example 1:

Input: nums = [2,2,3,2]
Output: 3


Example 2:

Input: nums = [0,1,0,1,0,1,99]
Output: 99


Constraints:

1 <= nums.length <= 3 * 10^4  
-2^31 <= nums[i] <= 2^31 - 1  
Each element in nums appears exactly three times
except for one element which appears once.



class Solution {
public:
    int singleNumber(vector<int>& nums) 
    {    
        int result = 0;

        for (int i = 0; i <= 31; i++)
        {   
            int temp = (1 << i);
            int countones = 0;

            for (int num : nums)
            {
                if (num & temp)
                    countones++;                       // goes at each number ith bit position
            }

            if (countones % 3 == 1)                   // only countones is required, because it will help in xoring.
                result |= temp;
        }

        return result;
    }
};
Approach 1: Bit Counting (Bit Manipulation)

Every number appears three times except one.

For each bit position (0 to 31), count how many numbers have that bit set.

Since repeated numbers appear 3 times, their bit counts will be multiples of 3.

The remaining bit (count % 3 == 1) belongs to the single number.

Rebuild the answer by setting those bits.

Key idea:
Bits repeating 3 times cancel out using modulo 3.

Time Complexity: O(32 × N) ≈ O(N)
Space Complexity: O(1)


Approach 2

class Solution {
public:
    int singleNumber(vector<int>& nums) 
    {
        int ones = 0;
        int twos = 0;

        for (int x : nums)
        {
            ones = (ones ^ x) & ~twos;
            twos = (twos ^ x) & ~ones;
        }

        return ones;
    }
};
Approach 2: State Machine using Bitwise XOR

Uses two variables:

ones → stores bits appearing once

twos → stores bits appearing twice

When a bit appears the third time, it is removed from both ones and twos.

This works like a modulo-3 counter for each bit.

Key idea:
Track bit frequency using XOR and masking instead of counting.

Time Complexity: O(N)
Space Complexity: O(1)

both have same tc and sc.
