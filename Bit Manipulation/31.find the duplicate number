/*
====================================================
Find the Duplicate Number
====================================================

Given an array of integers nums containing n + 1 integers
where each integer is in the range [1, n] inclusive.

There is only one repeated number in nums.
Return this repeated number.

You must solve the problem:
- Without modifying the array nums
- Using only constant extra space

----------------------------------------------------
Example 1:
Input:  nums = [1,3,4,2,2]
Output: 2

----------------------------------------------------
Example 2:
Input:  nums = [3,1,3,4,2]
Output: 3

----------------------------------------------------
Example 3:
Input:  nums = [3,3,3,3,3]
Output: 3

----------------------------------------------------
Constraints:
- 1 <= n <= 10^5
- nums.length == n + 1
- 1 <= nums[i] <= n
- Only one integer appears two or more times

----------------------------------------------------
Follow Up:
- Why must at least one duplicate exist?
- Can you solve this in linear time?
====================================================
*/


class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int duplicate = 0;

        for (int bit = 0; bit < 32; bit++)
        {
            int countnums = 0;
            int countrange = 0;

            for (int x : nums)
            {
                if (x & (1 << bit))
                {
                    countnums++;
                }
            }

            for (int i = 1; i <= nums.size() - 1; i++)
            {
                if (i & (1 << bit))
                {
                    countrange++;
                }
            }

            if (countrange < countnums)
            {
                duplicate |= (1 << bit);
            }
        }

        return duplicate;
    }
};
