Given an integer n, return the number of prime numbers that are strictly less than n.

 

Example 1:

Input: n = 10
Output: 4
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.

Example 2:

Input: n = 0
Output: 0

Example 3:

Input: n = 1
Output: 0


class Solution {
public:
    int countPrimes(int n) 
    {   
        vector<bool>isprime(n,true);
        if (n <= 2) return 0;
        
            for(int i=2;i*i<n;i++)
            {
                for(int p=i*i;p<n;p+=i)
                {
                   isprime[p]=false;
                }
            }

            
            int count=0;
             for(int i=2;i<n;i++)  
           {  
            if(isprime[i]==true) 
                count++;
            }
        return count;
    }
};








#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<bool> isprime(101, true);

    isprime[0] = isprime[1] = false;

    for (int p = 2; p * p < 100; p++) {
        if (isprime[p]) {
            for (int i = p * p; i < 100; i += p) {
                isprime[i] = false;
            }
        }
    }

    cout << "The prime numbers between 1 to 100 are:\n";
    for (int i = 2; i < 100; i++) {
        if (isprime[i]) {
            cout << i << " ";
        }
    }

    return 0;
}

Explanation of Code (Sieve of Eratosthenes)

The program finds all prime numbers between 1 and 100 using the Sieve of Eratosthenes method.

Steps:

Create a boolean array isprime[101] and assume all numbers are prime initially (true).

Mark 0 and 1 as not prime (false).

Starting from p = 2, mark all multiples of p (like 2p, 3p, 4p...) as not prime.

We start marking from p * p because smaller multiples are already marked by smaller primes.

Repeat the process for all numbers up to √100.

Finally, print all numbers that are still marked true → these are the prime numbers.

Time Complexity:The sieve runs in O(N log log N), which is much faster than checking each number individually.

for prime harmonic seris(1/2 + 1/3 + ..) it converge loglogn + c 
where C is Mertens’ constant (~0.261).
Total Work ≈ n * log(log n)
