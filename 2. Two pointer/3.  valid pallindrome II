VALID PALINDROME II
────────────────────────────────────────────────────────────────────────────────────────

Given a string s, return true if the s can be palindrome
after deleting at most ONE character.


EXAMPLE 1
────────────────────────────────────────────────────────────────────────────────────────
Input:  s = "aba"
Output: true


EXAMPLE 2
────────────────────────────────────────────────────────────────────────────────────────
Input:  s = "abca"
Output: true
Explanation:
Delete 'c' → "aba" which is palindrome.


EXAMPLE 3
────────────────────────────────────────────────────────────────────────────────────────
Input:  s = "abc"
Output: false


CONSTRAINTS
────────────────────────────────────────────────────────────────────────────────────────
1 <= s.length <= 10^5
s consists of lowercase English letters.


APPROACH (TWO POINTER + ONE SKIP)
────────────────────────────────────────────────────────────────────────────────────────
1. Use two pointers i (start) and j (end).
2. If characters match → move both pointers.
3. If mismatch occurs:
      try skipping left character  OR  skipping right character
      check if remaining substring is palindrome.
4. If any works → true.


TIME COMPLEXITY : O(n)  
SPACE COMPLEXITY : O(1)


CODE
────────────────────────────────────────────────────────────────────────────────────────

class Solution {
public:

    bool pallindrome(string s, int i, int j)
    {
        while(i < j)
        {
            if(s[i] == s[j])
            {
                i++;
                j--;
            }
            else
            {
                return false;
            }
        }
        return true;
    }

    bool validPalindrome(string s)
    {
        int i = 0;
        int j = s.size() - 1;

        while(i < j)
        {
            if(s[i] == s[j])
            {
                i++;
                j--;
            }
            else
            {
                return (pallindrome(s, i + 1, j) || pallindrome(s, i, j - 1));
            }
        }

        return true;
    }
};
