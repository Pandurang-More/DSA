REMOVE DUPLICATES FROM SORTED ARRAY
────────────────────────────────────────────────────────────────────────────────────────

Given an integer array nums sorted in non-decreasing order,
remove the duplicates in-place such that each unique element
appears only once. The relative order of the elements should
be kept the same.

Consider the number of unique elements in nums to be k.
After removing duplicates, return the number of unique elements k.

The first k elements of nums should contain the unique numbers
in sorted order. The remaining elements beyond index k - 1
can be ignored.


Custom Judge:

int[] nums = [...];          // Input array
int[] expectedNums = [...];  // Expected answer

int k = removeDuplicates(nums);

assert k == expectedNums.length;
for (int i = 0; i < k; i++)
{
    assert nums[i] == expectedNums[i];
}


Example 1:
Input:  nums = [1,1,2]
Output: 2, nums = [1,2,_]


Example 2:
Input:  nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]


Constraints:
1 <= nums.length <= 3 * 10^4
-100 <= nums[i] <= 100
nums is sorted in non-decreasing order


APPROACH (Two Pointer Technique)
────────────────────────────────────────────────────────────────────────────────────────
• Pointer i keeps track of last unique element
• Pointer j scans the array
• When a new unique element is found → place it at i+1
• Resize array to contain only unique elements


class Solution {
public:
    vector<int> removeDuplicates(vector<int> &arr) 
    {
        int i = 0;
        int n = arr.size();

        for (int j = 1; j < n; j++) 
        {
            if (arr[j] != arr[i]) 
            {
                arr[i + 1] = arr[j];
                i++;
            }
        }

        arr.resize(i + 1);
        return arr;
    }
};


NOTE:
────────────────────────────────────────────────────────────────────────────────────────
We can use set, but time complexity becomes O(n log n)
because each insertion in set takes O(log n).
