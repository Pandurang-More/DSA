/*
====================================================
Two Sum
====================================================

Given an array of integers nums and an integer target,
return indices of the two numbers such that they add
up to target.

You may assume:
- Each input has exactly one solution
- You may not use the same element twice
- Answer can be returned in any order

----------------------------------------------------
Example 1:
Input:  nums = [2,7,11,15], target = 9
Output: [0,1]

----------------------------------------------------
Example 2:
Input:  nums = [3,2,4], target = 6
Output: [1,2]

----------------------------------------------------
Example 3:
Input:  nums = [3,3], target = 6
Output: [0,1]
====================================================
*/


/* ==================================================
   Approach 1: Brute Force
   Time Complexity: O(n*n)
   Space Complexity: O(1)
   ================================================== */
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();

        for (int i = 0; i < n - 1; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                if (nums[i] + nums[j] == target)
                    return {i, j};
            }
        }
        return {};
    }
};



/* ==================================================
   Approach 2: Hash Map
   Time Complexity: O(n)
   Space Complexity: O(n)
   ================================================== */
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> mp; // value -> index

        for (int i = 0; i < nums.size(); i++) {
            int need = target - nums[i];

            // if needed number already seen
            if (mp.count(need)) {
                return {mp[need], i};
            }

            // store current number
            mp[nums[i]] = i;
        }
        return {};
    }
};
