/*
====================================================
Two Sum
====================================================

Given an array of integers nums and an integer target,
return indices of the two numbers such that they add
up to target.

You may assume:
- Each input has exactly one solution
- You may not use the same element twice
- Answer can be returned in any order

----------------------------------------------------
Example 1:
Input:  nums = [2,7,11,15], target = 9
Output: [0,1]

----------------------------------------------------
Example 2:
Input:  nums = [3,2,4], target = 6
Output: [1,2]

----------------------------------------------------
Example 3:
Input:  nums = [3,3], target = 6
Output: [0,1]
====================================================
*/


/* ==================================================
   Approach 1: Brute Force
   Time Complexity: O(n*n)
   Space Complexity: O(1)
   ================================================== */
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();

        for (int i = 0; i < n - 1; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                if (nums[i] + nums[j] == target)
                    return {i, j};
            }
        }
        return {};
    }
};



/* ==================================================
   Approach 2: Hash Map
   Time Complexity: O(n)
   Space Complexity: O(n)
   ================================================== */
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> seen;

        for (int i = 0; i < nums.size(); i++)
        {
            int x = nums[i];
            int complement = target - x;

            // 1) Check if complement already exists
            auto it = seen.find(complement);   // O(1) average

            /*
            Case               Meaning                         find() result
            ---------------------------------------------------------------
            Key found          key exists in map               iterator to key-value pair
            Key not found      key does not exist              seen.end()
            */

            if (it != seen.end())
            {
                // Found indices where nums[it->second] + nums[i] == target
                return {it->second, i};
            }

            // 2) Store current value with index
            // Store AFTER checking to avoid using the same element twice
            seen[x] = i;
        }

        return {};
    }
};
