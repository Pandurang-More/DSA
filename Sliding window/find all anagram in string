
Given two strings s and p, return an array of all the start indices of p's anagrams in s. 
You may return the answer in any order.

 

Example 1:
Input: s = "cbaebabacd", p = "abc"
Output: [0,6]
Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".

Example 2:
Input: s = "abab", p = "ab"
Output: [0,1,2]
Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".
 

Constraints:

1 <= s.length, p.length <= 3 * 104
s and p consist of lowercase English letters.






class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        if (p.size() > s.size()) return {};
        
        vector<int> phash(256, 0);  // counts for p
        vector<int> shash(256, 0);  // counts for current window in s
        vector<int> ans;

        // Step 1: Fill frequency arrays for p and for first window in s
        for (int i = 0; i < p.size(); i++) {
            phash[p[i]]++;
            shash[s[i]]++;
        }

        // Step 2: Check the very first window (index 0)
        if (phash == shash) ans.push_back(0);

        // Step 3: Slide the window, now using "start" index
        for (int start = 1; start + p.size() <= s.size(); start++) {
            shash[s[start - 1]]--;                // remove old char (leftmost)
            shash[s[start + p.size() - 1]]++;     // add new char (rightmost)

            if (phash == shash) ans.push_back(start);  // start is the window's index
        }

        return ans;
    }
};


        // Return all starting indices of anagrams
        return ans;
    }
};
