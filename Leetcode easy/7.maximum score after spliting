/*
====================================================
Maximum Score After Splitting a String
====================================================

Given a string s of zeros and ones, return the maximum
score after splitting the string into two non-empty
substrings (left and right).

Score = (number of zeros in left substring)
      + (number of ones in right substring)

----------------------------------------------------
Example 1:
Input:  s = "011101"
Output: 5

Explanation:
left = "0",     right = "11101" → 1 + 4 = 5
left = "01",    right = "1101"  → 1 + 3 = 4
left = "011",   right = "101"   → 1 + 2 = 3
left = "0111",  right = "01"    → 1 + 1 = 2
left = "01110", right = "1"     → 2 + 1 = 3

----------------------------------------------------
Example 2:
Input:  s = "00111"
Output: 5

----------------------------------------------------
Example 3:
Input:  s = "1111"
Output: 3

----------------------------------------------------
Constraints:
- 2 <= s.length <= 500
- s consists only of '0' and '1'
====================================================
*/


/* ==================================================
   Approach 1: Brute Force
   Time Complexity: O(n^2)
   ================================================== */
class Solution {
public:
    int maxScore(string s) {

        int n = s.size();
        int maxScore = 0;

        for (int i = 0; i <= n - 2; i++)
        {
            int zerocount = 0;
            for (int j = 0; j <= i; j++)
            {
                if (s[j] == '0')
                    zerocount++;
            }

            int onecount = 0;
            for (int j = i + 1; j <= n - 1; j++)
            {
                if (s[j] == '1')
                    onecount++;
            }

            maxScore = max(maxScore, onecount + zerocount);
        }

        return maxScore;
    }
};



/* ==================================================
   Approach 2: Prefix Counting
   Time Complexity: O(n)
   ================================================== */
class Solution {
public:
    int maxScore(string s) {

        int n = s.size();
        int maxScore = 0;
        int totalone = 0;

        for (int i = 0; i <= n - 1; i++)
        {
            if (s[i] == '1')
                totalone++;
        }

        int zerocount = 0;
        int onecount = 0;
        int fcount = 0;

        for (int i = 0; i <= n - 2; i++)
        {
            if (s[i] == '0')
                zerocount++;
            else
                onecount++;

            fcount = totalone - onecount;
            maxScore = max(maxScore, fcount + zerocount);
        }

        return maxScore;
    }
};



/* ==================================================
   Approach 3: Optimized (Max Difference Trick)
   Time Complexity: O(n)
   ================================================== */
   S=ZL+OR
   OT=OL+OR
   .. OR=OT-OL
   put above eq in S
hence S=ZL-OL+OT

ZL=ZERPLEFT
OL=ONE LEFT
OT=ZEROTOTAL
class Solution {
public:
    int maxScore(string s) {

        int n = s.size();
        int maxScore = INT_MIN;
        int totalone = 0;

        int zerocount = 0;
        int onecount = 0;

        for (int i = 0; i <= n - 1; i++)
        {
            if (s[i] == '1')
                totalone++;
        }

        for (int i = 0; i <= n - 2; i++)
        {
            if (s[i] == '0')
                zerocount++;
            else
                onecount++;

            maxScore = max(maxScore, zerocount - onecount);
        }

        if (s[n - 1] == '1')
            onecount++;

        return maxScore + totalone;
    }
};
