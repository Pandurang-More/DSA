CAR FLEET
────────────────────────────────────────────────────────────────────────

There are n cars traveling to reach the target.

• position[i] → starting mile  
• speed[i]    → speed of car  
• Cars cannot pass each other  
• Faster car catches slower → becomes fleet  
• Fleet speed = minimum speed in that fleet  
• Catching exactly at target → still same fleet  

Return number of car fleets reaching destination.



Example 1:
Input:
target = 12  
position = [10,8,0,5,3]  
speed    = [2,4,1,1,3]

Output: 3


Example 2:
Input:
target = 10  
position = [3]  
speed = [3]

Output: 1


Example 3:
Input:
target = 100  
position = [0,2,4]  
speed = [4,2,1]

Output: 1


Constraints:
1 <= n <= 10^5  
0 < target <= 10^6  
0 <= position[i] < target  
All position values unique  
0 < speed[i] <= 10^6  



────────────────────────────────────────────────────────────────────────
STACK + SORT APPROACH (O(n log n))
────────────────────────────────────────────────────────────────────────

class Solution {
public:
    int carFleet(int target, vector<int>& position, vector<int>& speed) {

        vector<pair<int,float>> cars;

        for(int i=0;i<position.size();i++)
        {
            double time = double(target - position[i]) / speed[i];
            cars.push_back({position[i], time});
        }

        sort(cars.begin(), cars.end());

        stack<double> st;

        for(int i=cars.size()-1;i>=0;i--)
        {
            double currtime = cars[i].second;

            if(st.empty() || currtime > st.top())
            {
                st.push(currtime);
            }
        }

        return st.size();
    }
};
