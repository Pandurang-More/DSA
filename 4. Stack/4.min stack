MIN STACK
────────────────────────────────────────────────────────────────────────

Design a stack that supports:

• push(val)
• pop()
• top()
• getMin()

All operations must run in O(1) time.


Example:

Input:
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

Output:
[null,null,null,null,-3,null,0,-2]

Explanation:
push(-2)
push(0)
push(-3)
getMin() → -3
pop()
top()    → 0
getMin() → -2


Constraints:
-2^31 <= val <= 2^31 - 1
pop, top, getMin always called on non-empty stack.
At most 3 * 10^4 calls.



────────────────────────────────────────────────────────────────────────
SOLUTION 1 → USING TWO STACKS
────────────────────────────────────────────────────────────────────────

class MinStack {
public:
     stack<int> st;
     stack<int> minst;
     
    MinStack() {
    }
    
    void push(int val) {
        st.push(val);

        if(minst.empty() || val <= minst.top())
        {
            minst.push(val);
        }
    }
    
    void pop() {
        if(st.top() == minst.top())
        {
            minst.pop();
        }
        st.pop();
    }
    
    int top() {
        return st.top();
    }
    
    int getMin() {
        return minst.top();
    }
};


/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */



────────────────────────────────────────────────────────────────────────
SOLUTION 2 → USING SINGLE STACK (SPACE OPTIMIZED)
────────────────────────────────────────────────────────────────────────

class MinStack {
public:
     stack<long long> st;
     long long mini;
     
    MinStack() {
    }
    
    void push(int val) {
       if(st.empty())
       {
            st.push(val);
            mini = val;
       }
       else if(val >= mini)
       {
            st.push(val);
       }
       else
       {
            st.push(2LL * val - mini);
            mini = val;
       }
    }

    void pop() {
       if(st.empty()) return;

       if(st.top() > mini)
       {
            st.pop();
       }
       else
       {
            mini = 2LL * mini - st.top();
            st.pop();
       }
    }
    
    int top() {
        if(st.top() >= mini)
            return st.top();
        else
            return mini;
    }
    
    int getMin() {
        return mini;
    }
};
