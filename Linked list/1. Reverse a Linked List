# using extra space vector:

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
       ListNode* temp=head;
       vector<int>ans;
       while(temp)
       {
        ans.push_back(temp->val);
        temp=temp->next;
       } 
       temp=head;
       int n=ans.size()-1;
       for( int i=n;i>=0;i--)
       {
          temp->val=ans[i];
          temp=temp->next;
       }
       temp=head;
       return head;


    }
};





# without a extra space;

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = NULL;
        ListNode* curr = head;  // using three pointer
        ListNode* fut = NULL;
        while (curr) {
            fut = curr->next;
            curr->next = prev;
            prev = curr;
            curr = fut;
        }
        head = prev;
        return head;
    }
};

 Using recursion:


 ListNode* reverse (ListNode *curr,ListNode *prev)
    {
        if(curr==NULL)
        return prev;
        
        
        ListNode *fut=curr->next;
        curr->next=prev;              // using three pointer
        return  reverse(fut,curr);
        

    };


class Solution {
public:
    ListNode* reverseList(ListNode* head) {
       
      return reverse(head ,NULL);

    }
};


Call order (forward phase):

reverse(curr = 1, prev = NULL)

fut = 2

1->next = NULL


Calls → reverse(2, 1)

reverse(curr = 2, prev = 1)

fut = 3

2->next = 1


Calls → reverse(3, 2)

reverse(curr = 3, prev = 2)

fut = 4

3->next = 2


Calls → reverse(4, 3)

reverse(curr = 4, prev = 3)

fut = NULL

4->next = 3


Calls → reverse(NULL, 4)

reverse(curr = NULL, prev = 4)

Base case → returns 4 (new head)



Return order (unwinding phase):

reverse(NULL, 4) returns 4

reverse(4, 3) returns 4

reverse(3, 2) returns 4

reverse(2, 1) returns 4

reverse(1, NULL) returns 4


✅ Final result: new head = 4
