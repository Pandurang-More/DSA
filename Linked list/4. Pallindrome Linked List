
#  #  two pointer approach

time complexity: O(n)
space complexity:O(1)

class Solution {
public:
    bool isPalindrome(ListNode* head)
     {

       
        if(head==NULL || head->next==NULL)
        {
            return true;                             // single and empty node is always pallindrome.
        }
         
        ListNode *fast=head;
        ListNode *slow=head;

        while(fast && fast->next)            // use slow and fast to find the mid of linked list.
        {
            slow=slow->next;
            fast=fast->next->next;
        }
        
       
        if(fast!=NULL)
        {   
            slow=slow->next;           // if linked list contain odd element then skip the element.
        }

        ListNode *prevn=NULL;
        ListNode *fut=NULL;
                
         while(slow)              // reverse the second half.
        {
            fut=slow->next;
            slow->next=prevn;
            prevn=slow;
            slow=fut;
         }
    
          
        ListNode *head1=prevn;
        ListNode *head2=head;


        bool isPalin = true;

     while(head1 != NULL)
       {
         if(head1->val != head2->val)       // compare the first and reverse second half.
         {
            isPalin = false;
            break;
         }
         head1 = head1->next;
         head2 = head2->next;
      }

     
           // Restore second half
           
        ListNode* curr = prevn;          // start of reversed second half
        prevn = NULL;
        fut = NULL;

        while(curr)
           {
             fut = curr->next;
             curr->next = prevn;
             prevn = curr;
            curr = fut;
           }

     return isPalin;

     }

    
};


recursion
time complexity:O(n)
space complexuty:O(n)


class Solution {
public:
    ListNode* front;  // pointer starting from head

    bool isPalindrome(ListNode* head) {
        front = head;           // initialize front pointer
        return check(head);     // start recursion
    }

private:
    bool check(ListNode* current) {
        if (!current)           // base case: end of list
            return true;

        // Recurse to the end first
        if (!check(current->next)) // early exit if deeper nodes are not palindrome
            return false;

        // Compare mirrored nodes
        if (current->val != front->val)
            return false;

        // Move front pointer forward
        front = front->next;
         return true;
    }
};
